import { io, Socket } from 'socket.io-client';

export interface LocationData {
  latitude: number;
  longitude: number;
  accuracy: number;
  timestamp: number;
  speed?: number;
  heading?: number;
}

class LocationService {
  private socket: Socket | null = null;
  private watchId: number | null = null;
  private commercialId: string | null = null;
  private isTracking = false;
  private heartbeatInterval: number | null = null;
  private lastPosition: LocationData | null = null;

  constructor() {
    this.initializeSocket();
  }

  private initializeSocket() {
    const SERVER_HOST = import.meta.env.VITE_SERVER_HOST || window.location.hostname;
    const API_PORT = import.meta.env.VITE_API_PORT || '3000';
    
    // Use different URLs for development vs production
    const isDevelopment = SERVER_HOST === 'localhost' || SERVER_HOST === '127.0.0.1' || SERVER_HOST.startsWith('192.168.');
    const socketUrl = isDevelopment ? `https://${SERVER_HOST}:${API_PORT}` : `https://${SERVER_HOST}`;
    console.log('üîå Initialisation socket GPS:', socketUrl);
    
    this.socket = io(socketUrl, {
      secure: true,
      transports: ['polling', 'websocket'], // Polling en premier pour mobile
      reconnection: true,
      reconnectionAttempts: 10,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 20000,
      forceNew: true, // Force une nouvelle connexion
      rejectUnauthorized: false, // Accepter les certificats auto-sign√©s
    });

    this.socket.on('connect', () => {
      console.log('üìç Service GPS connect√©');
      if (this.commercialId) {
        this.socket?.emit('joinRoom', 'gps-tracking');
      }
    });

    this.socket.on('disconnect', (reason) => {
      console.log('üìç Service GPS d√©connect√©:', reason);
    });

    this.socket.on('connect_error', (error) => {
      console.log('‚ùå Erreur connexion GPS:', error.message);
    });

    this.socket.on('reconnect', (attemptNumber) => {
      console.log('üîÑ GPS reconnect√© apr√®s', attemptNumber, 'tentatives');
      if (this.commercialId) {
        this.socket?.emit('joinRoom', 'gps-tracking');
      }
    });

    this.socket.on('reconnect_failed', () => {
      console.log('‚ùå Impossible de reconnecter le GPS');
    });
  }

  async startTracking(commercialId: string): Promise<boolean> {
    if (this.isTracking && this.commercialId === commercialId) {
      console.log('üìç Suivi GPS d√©j√† actif pour ce commercial');
      return true;
    }

    // Si on change de commercial, arr√™ter l'ancien suivi
    if (this.isTracking) {
      this.stopTracking();
    }

    this.commercialId = commercialId;

    // V√©rifier si la g√©olocalisation est support√©e
    if (!navigator.geolocation) {
      console.error('‚ùå G√©olocalisation non support√©e par ce navigateur');
      return false;
    }

    // V√©rifier HTTPS sur mobile
    if (!window.location.protocol.startsWith('https') && window.location.hostname !== 'localhost') {
      console.error('‚ùå HTTPS requis pour la g√©olocalisation sur mobile');
      alert('La g√©olocalisation n√©cessite une connexion s√©curis√©e (HTTPS)');
      return false;
    }

    try {
      console.log('üìç Tentative d\'acc√®s √† la g√©olocalisation...');
      
      // S'assurer que le socket est connect√©
      if (!this.socket?.connected) {
        console.log('üîÑ Attente de la connexion socket...');
        await new Promise<void>((resolve) => {
          if (this.socket?.connected) {
            resolve();
          } else {
            this.socket?.once('connect', () => resolve());
            // Timeout apr√®s 10 secondes
            setTimeout(() => resolve(), 10000);
          }
        });
      }

      // Rejoindre la room GPS
      this.socket?.emit('joinRoom', 'gps-tracking');
      
      // Tentative directe d'obtenir la position (cela d√©clenchera la demande de permission)
      const position = await this.getCurrentPositionWithRetry();
      console.log('‚úÖ Permission GPS accord√©e et position obtenue');

      // Envoyer la position initiale
      this.sendLocationUpdate({
        latitude: position.coords.latitude,
        longitude: position.coords.longitude,
        accuracy: position.coords.accuracy,
        timestamp: position.timestamp,
        speed: position.coords.speed || undefined,
        heading: position.coords.heading || undefined,
      });

      // D√©marrer le suivi en temps r√©el
      this.watchId = navigator.geolocation.watchPosition(
        (position) => {
          const locationData: LocationData = {
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy,
            timestamp: position.timestamp,
            speed: position.coords.speed || undefined,
            heading: position.coords.heading || undefined,
          };

          this.sendLocationUpdate(locationData);
        },
        (error) => {
          console.error('Erreur de g√©olocalisation:', error.message);
          this.handleLocationError(error);
        },
        {
          enableHighAccuracy: true, // Haute pr√©cision pour √©viter POSITION_UNAVAILABLE
          timeout: 90000, // 90 secondes pour watchPosition
          maximumAge: 60000, // Cache de 60 secondes
        }
      );

      this.isTracking = true;
      console.log('Suivi GPS d√©marr√© pour commercial:', commercialId);
      
      // D√©marrer le heartbeat pour maintenir la connexion
      this.startHeartbeat();
      
      return true;

    } catch (error) {
      console.error('Impossible d\'obtenir la position:', error);
      return false;
    }
  }

  stopTracking() {
    if (this.watchId !== null) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
    }

    // Arr√™ter le heartbeat
    this.stopHeartbeat();

    if (this.socket && this.commercialId) {
      this.socket.emit('commercialOffline', this.commercialId);
    }

    this.isTracking = false;
    this.commercialId = null;
    this.lastPosition = null;
    console.log('üìç Suivi GPS arr√™t√©');
  }

  private getCurrentPosition(): Promise<GeolocationPosition> {
    return new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(
        resolve,
        reject,
        {
          enableHighAccuracy: true, // Pr√©cision √©lev√©e pour √©viter POSITION_UNAVAILABLE
          timeout: 60000, // 60 secondes - plus long timeout
          maximumAge: 60000, // Cache de 1 minute seulement
        }
      );
    });
  }

  private async getCurrentPositionWithRetry(maxRetries = 5): Promise<GeolocationPosition> {
    for (let i = 0; i < maxRetries; i++) {
      try {
        console.log(`üìç Tentative GPS ${i + 1}/${maxRetries}...`);
        
        // Configuration progressive : d'abord haute pr√©cision, puis d√©grad√©e
        const options = {
          enableHighAccuracy: i < 2, // Haute pr√©cision pour les 2 premi√®res tentatives
          timeout: 45000 + (i * 15000), // Timeout croissant: 45s, 60s, 75s...
          maximumAge: i === 0 ? 0 : 300000, // Pas de cache pour la premi√®re tentative
        };
        
        console.log(`Configuration tentative ${i + 1}:`, options);
        
        return await new Promise<GeolocationPosition>((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, options);
        });
      } catch (error) {
        console.log(`Tentative ${i + 1} √©chou√©e:`, error);
        
        // Analyser le type d'erreur
        if (error instanceof GeolocationPositionError) {
          if (error.code === error.PERMISSION_DENIED) {
            // Permission refus√©e, pas la peine de r√©essayer
            throw error;
          }
        }
        
        if (i === maxRetries - 1) {
          throw error; // Derni√®re tentative, on lance l'erreur
        }
        
        // Attendre progressivement plus longtemps entre les tentatives
        const delay = 2000 + (i * 1000); // 2s, 3s, 4s, 5s
        console.log(`‚è±Ô∏è Attente ${delay}ms avant la prochaine tentative...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    throw new Error('Toutes les tentatives ont √©chou√©');
  }

  private sendLocationUpdate(locationData: LocationData) {
    if (!this.socket || !this.commercialId) return;

    // Sauvegarder la derni√®re position pour le heartbeat
    this.lastPosition = locationData;

    const updateData = {
      commercialId: this.commercialId,
      position: [locationData.latitude, locationData.longitude] as [number, number],
      timestamp: new Date(locationData.timestamp).toISOString(),
      speed: locationData.speed,
      heading: locationData.heading,
      accuracy: locationData.accuracy,
    };

    this.socket.emit('locationUpdate', updateData);
    console.log('üìç Position envoy√©e:', updateData);
  }

  private startHeartbeat() {
    // Arr√™ter le heartbeat existant s'il y en a un
    this.stopHeartbeat();

    // Envoyer un heartbeat toutes les 30 secondes pour maintenir la connexion
    this.heartbeatInterval = setInterval(() => {
      if (this.socket?.connected && this.commercialId && this.lastPosition) {
        // Renvoyer la derni√®re position connue comme heartbeat
        this.sendLocationUpdate(this.lastPosition);
        console.log('üíì Heartbeat GPS envoy√©');
      }
    }, 30000); // 30 secondes

    console.log('üíì Heartbeat GPS d√©marr√©');
  }

  private stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
      console.log('üíì Heartbeat GPS arr√™t√©');
    }
  }

  private handleLocationError(error: GeolocationPositionError) {
    let message = '';
    let shouldRetry = false;
    
    switch (error.code) {
      case error.PERMISSION_DENIED:
        message = 'Permission de g√©olocalisation refus√©e';
        this.showLocationInstructions();
        break;
      case error.POSITION_UNAVAILABLE:
        message = 'Position non disponible - V√©rifiez que le GPS est activ√© et que vous √™tes √† l\'ext√©rieur';
        shouldRetry = true;
        break;
      case error.TIMEOUT:
        message = 'Timeout de g√©olocalisation - Tentative de reconnexion...';
        shouldRetry = true;
        break;
      default:
        message = 'Erreur de g√©olocalisation inconnue';
        break;
    }

    console.error('Erreur GPS:', message, error);
    
    // Tentative de r√©cup√©ration automatique pour certaines erreurs
    if (shouldRetry && this.isTracking) {
      console.log('üîÑ Tentative de r√©cup√©ration GPS dans 10 secondes...');
      setTimeout(() => {
        if (this.isTracking && this.commercialId) {
          console.log('üîÑ Red√©marrage du suivi GPS...');
          // Red√©marrer le tracking
          this.getCurrentPositionWithRetry()
            .then(position => {
              console.log('‚úÖ GPS r√©cup√©r√© avec succ√®s');
              this.sendLocationUpdate({
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp,
                speed: position.coords.speed || undefined,
                heading: position.coords.heading || undefined,
              });
            })
            .catch(retryError => {
              console.error('Impossible de r√©cup√©rer le GPS:', retryError);
            });
        }
      }, 10000);
    }
    
    // Notifier l'admin que le commercial a un probl√®me GPS
    if (this.socket && this.commercialId) {
      this.socket.emit('locationError', {
        commercialId: this.commercialId,
        error: message,
        timestamp: new Date().toISOString(),
        shouldRetry,
      });
    }
  }

  getTrackingStatus() {
    return {
      isTracking: this.isTracking,
      commercialId: this.commercialId,
      isConnected: this.socket?.connected || false,
    };
  }

  // M√©thode pour tester la g√©olocalisation
  async testGeolocation(): Promise<boolean> {
    try {
      const position = await this.getCurrentPosition();
      console.log('üß™ Test GPS r√©ussi:', {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy,
      });
      return true;
    } catch (error) {
      console.error('üß™ Test GPS √©chou√©:', error);
      return false;
    }
  }

  // M√©thode pour guider l'utilisateur sur l'activation GPS
  showLocationInstructions() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isAndroid = /Android/.test(navigator.userAgent);
    
    let instructions = '';
    
    if (isIOS) {
      instructions = `
INSTRUCTIONS POUR iOS:
1. Ouvrez R√©glages > Confidentialit√© et s√©curit√© > Service de localisation
2. Activez "Service de localisation"
3. Trouvez Safari dans la liste et s√©lectionnez "Lors de l'utilisation de l'app"
4. Rechargez cette page et autorisez l'acc√®s √† la localisation
      `.trim();
    } else if (isAndroid) {
      instructions = `
INSTRUCTIONS POUR ANDROID:
1. Ouvrez Param√®tres > Applications > Chrome (ou votre navigateur)
2. Appuyez sur "Autorisations"
3. Activez "Position"
4. Rechargez cette page et autorisez l'acc√®s √† la localisation
      `.trim();
    } else {
      instructions = `
INSTRUCTIONS:
1. Cliquez sur l'ic√¥ne de localisation dans la barre d'adresse
2. S√©lectionnez "Toujours autoriser" ou "Autoriser"
3. Rechargez la page si n√©cessaire
      `.trim();
    }
    
    console.log(instructions);
    alert(instructions);
  }
}

export const locationService = new LocationService();