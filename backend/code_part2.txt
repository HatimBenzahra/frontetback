

# --- prisma/seed.ts ---
import { PrismaClient, AssignmentType, ImmeubleStatus, ProspectingMode, PorteStatut } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  console.log(`Start seeding ...`);

  // --- Managers ---
  const manager1 = await prisma.manager.upsert({
    where: { email: 'jean.dupont@example.com' },
    update: {},
    create: {
      nom: 'Dupont',
      prenom: 'Jean',
      email: 'jean.dupont@example.com',
      telephone: '0123456789',
    },
  });
  console.log(`Created manager: ${manager1.prenom} ${manager1.nom}`);

  const manager2 = await prisma.manager.upsert({
    where: { email: 'marie.curie@example.com' },
    update: {},
    create: {
      nom: 'Curie',
      prenom: 'Marie',
      email: 'marie.curie@example.com',
      telephone: '0987654321',
    },
  });
  console.log(`Created manager: ${manager2.prenom} ${manager2.nom}`);

  // --- Equipes ---
  const equipeAlpha = await prisma.equipe.upsert({
    where: { nom_managerId: { nom: 'Équipe Alpha', managerId: manager1.id } },
    update: {},
    create: {
      nom: 'Équipe Alpha',
      managerId: manager1.id,
    },
  });
  console.log(`Created equipe: ${equipeAlpha.nom}`);

  const equipeBeta = await prisma.equipe.upsert({
    where: { nom_managerId: { nom: 'Équipe Beta', managerId: manager1.id } },
    update: {},
    create: {
      nom: 'Équipe Beta',
      managerId: manager1.id,
    },
  });
  console.log(`Created equipe: ${equipeBeta.nom}`);

  const equipeGamma = await prisma.equipe.upsert({
    where: { nom_managerId: { nom: 'Équipe Gamma', managerId: manager2.id } },
    update: {},
    create: {
      nom: 'Équipe Gamma',
      managerId: manager2.id,
    },
  });
  console.log(`Created equipe: ${equipeGamma.nom}`);

  // --- Commerciaux ---
  const commercialAlice = await prisma.commercial.upsert({
    where: { email: 'alice.martin@example.com' },
    update: {},
    create: {
      nom: 'Martin',
      prenom: 'Alice',
      email: 'alice.martin@example.com',
      equipeId: equipeAlpha.id,
      managerId: manager1.id,
    },
  });
  console.log(`Created commercial: ${commercialAlice.prenom} ${commercialAlice.nom}`);

  const commercialBob = await prisma.commercial.upsert({
    where: { email: 'bob.durand@example.com' },
    update: {},
    create: {
      nom: 'Durand',
      prenom: 'Bob',
      email: 'bob.durand@example.com',
      equipeId: equipeAlpha.id,
      managerId: manager1.id,
    },
  });
  console.log(`Created commercial: ${commercialBob.prenom} ${commercialBob.nom}`);

  const commercialCharlie = await prisma.commercial.upsert({
    where: { email: 'charlie.leblanc@example.com' },
    update: {},
    create: {
      nom: 'Leblanc',
      prenom: 'Charlie',
      email: 'charlie.leblanc@example.com',
      equipeId: equipeBeta.id,
      managerId: manager1.id,
    },
  });
  console.log(`Created commercial: ${commercialCharlie.prenom} ${commercialCharlie.nom}`);

  const commercialDiana = await prisma.commercial.upsert({
    where: { email: 'diana.rousseau@example.com' },
    update: {},
    create: {
      nom: 'Rousseau',
      prenom: 'Diana',
      email: 'diana.rousseau@example.com',
      equipeId: equipeGamma.id,
      managerId: manager2.id,
    },
  });
  console.log(`Created commercial: ${commercialDiana.prenom} ${commercialDiana.nom}`);

  // --- Zones ---
  const zoneCentreVille = await prisma.zone.upsert({
    where: { nom_typeAssignation: { nom: 'Zone Centre-Ville', typeAssignation: AssignmentType.EQUIPE } },
    update: {},
    create: {
      nom: 'Zone Centre-Ville',
      latitude: 45.764043,
      longitude: 4.835659,
      rayonMetres: 1500,
      couleur: '#FF5733',
      typeAssignation: AssignmentType.EQUIPE,
      equipeId: equipeAlpha.id,
    },
  });
  console.log(`Created zone: ${zoneCentreVille.nom}`);

  const zonePeripherieNord = await prisma.zone.upsert({
    where: { nom_typeAssignation: { nom: 'Zone Périphérie Nord', typeAssignation: AssignmentType.EQUIPE } },
    update: {},
    create: {
      nom: 'Zone Périphérie Nord',
      latitude: 45.800000,
      longitude: 4.850000,
      rayonMetres: 2000,
      couleur: '#33FF57',
      typeAssignation: AssignmentType.EQUIPE,
      equipeId: equipeBeta.id,
    },
  });
  console.log(`Created zone: ${zonePeripherieNord.nom}`);

  const zoneSudEst = await prisma.zone.upsert({
    where: { nom_typeAssignation: { nom: 'Zone Sud-Est', typeAssignation: AssignmentType.EQUIPE } },
    update: {},
    create: {
      nom: 'Zone Sud-Est',
      latitude: 45.700000,
      longitude: 4.900000,
      rayonMetres: 1800,
      couleur: '#5733FF',
      typeAssignation: AssignmentType.EQUIPE,
      equipeId: equipeGamma.id,
    },
  });
  console.log(`Created zone: ${zoneSudEst.nom}`);

  // --- Immeubles ---
  const immeuble1 = await prisma.immeuble.create({
    data: {
      adresse: '123 Rue de la République',
      ville: 'Lyon',
      codePostal: '69002',
      status: ImmeubleStatus.A_VISITER,
      nbPortesTotal: 5,
      prospectingMode: ProspectingMode.SOLO,
      zoneId: zoneCentreVille.id,
      latitude: 45.763,
      longitude: 4.834,
      hasElevator: true,
      digicode: '12A34',
      prospectors: {
        connect: { id: commercialAlice.id },
      },
    },
  });
  console.log(`Created immeuble: ${immeuble1.adresse}`);

  const immeuble2 = await prisma.immeuble.create({
    data: {
      adresse: '456 Avenue des Frères Lumière',
      ville: 'Lyon',
      codePostal: '69008',
      status: ImmeubleStatus.A_VISITER,
      nbPortesTotal: 8,
      prospectingMode: ProspectingMode.DUO,
      zoneId: zoneCentreVille.id,
      latitude: 45.749,
      longitude: 4.872,
      hasElevator: false,
      prospectors: {
        connect: [{ id: commercialAlice.id }, { id: commercialBob.id }],
      },
    },
  });
  console.log(`Created immeuble: ${immeuble2.adresse}`);

  const immeuble3 = await prisma.immeuble.create({
    data: {
      adresse: '789 Boulevard de la Croix-Rousse',
      ville: 'Lyon',
      codePostal: '69004',
      status: ImmeubleStatus.A_VISITER,
      nbPortesTotal: 10,
      prospectingMode: ProspectingMode.SOLO,
      zoneId: zonePeripherieNord.id,
      latitude: 45.778,
      longitude: 4.828,
      hasElevator: true,
      digicode: 'B45C',
      prospectors: {
        connect: { id: commercialCharlie.id },
      },
    },
  });
  console.log(`Created immeuble: ${immeuble3.adresse}`);

  const immeuble4 = await prisma.immeuble.create({
    data: {
      adresse: '101 Rue Garibaldi',
      ville: 'Lyon',
      codePostal: '69003',
      status: ImmeubleStatus.A_VISITER,
      nbPortesTotal: 6,
      prospectingMode: ProspectingMode.DUO,
      zoneId: zoneSudEst.id,
      latitude: 45.758,
      longitude: 4.858,
      hasElevator: false,
      prospectors: {
        connect: [{ id: commercialDiana.id }, { id: commercialBob.id }], // Bob peut aussi travailler dans cette zone
      },
    },
  });
  console.log(`Created immeuble: ${immeuble4.adresse}`);

  // --- Portes for Immeubles ---
  const portesImmeuble1 = Array.from({ length: immeuble1.nbPortesTotal }, (_, i) => ({
    numeroPorte: `Porte ${101 + i}`,
    statut: PorteStatut.NON_VISITE,
    passage: 0,
    immeubleId: immeuble1.id,
  }));
  await prisma.porte.createMany({ data: portesImmeuble1, skipDuplicates: true });
  console.log(`Created ${immeuble1.nbPortesTotal} portes for immeuble ${immeuble1.adresse}`);

  const portesImmeuble2 = Array.from({ length: immeuble2.nbPortesTotal }, (_, i) => ({
    numeroPorte: `Apt ${'A'.charCodeAt(0) + i}`,
    statut: PorteStatut.NON_VISITE,
    passage: 0,
    immeubleId: immeuble2.id,
  }));
  await prisma.porte.createMany({ data: portesImmeuble2, skipDuplicates: true });
  console.log(`Created ${immeuble2.nbPortesTotal} portes for immeuble ${immeuble2.adresse}`);

  const portesImmeuble3 = Array.from({ length: immeuble3.nbPortesTotal }, (_, i) => ({
    numeroPorte: `Appt ${201 + i}`,
    statut: PorteStatut.NON_VISITE,
    passage: 0,
    immeubleId: immeuble3.id,
  }));
  await prisma.porte.createMany({ data: portesImmeuble3, skipDuplicates: true });
  console.log(`Created ${immeuble3.nbPortesTotal} portes for immeuble ${immeuble3.adresse}`);

  const portesImmeuble4 = Array.from({ length: immeuble4.nbPortesTotal }, (_, i) => ({
    numeroPorte: `Lot ${1 + i}`,
    statut: PorteStatut.NON_VISITE,
    passage: 0,
    immeubleId: immeuble4.id,
  }));
  await prisma.porte.createMany({ data: portesImmeuble4, skipDuplicates: true });
  console.log(`Created ${immeuble4.nbPortesTotal} portes for immeuble ${immeuble4.adresse}`);

  // --- HistoriqueProspection ---
  const today = new Date();
  const historicalEntries = [];

  for (let i = 5; i >= 0; i--) {
    const date = new Date(today.getFullYear(), today.getMonth() - i, 15);

    historicalEntries.push(
      // Alice - Immeuble 1
      {
        dateProspection: new Date(date.setDate(1)),
        commercialId: commercialAlice.id,
        immeubleId: immeuble1.id,
        nbPortesVisitees: 3 + i, nbContratsSignes: 1 + i, nbRdvPris: 1, nbRefus: 0, nbAbsents: 1,
        commentaire: `Visite mois ${i}, 1 contrat.`,
      },
      {
        dateProspection: new Date(date.setDate(5)),
        commercialId: commercialAlice.id,
        immeubleId: immeuble1.id,
        nbPortesVisitees: 2 + i, nbContratsSignes: 0, nbRdvPris: 1, nbRefus: 1, nbAbsents: 0,
        commentaire: `Suivi mois ${i}, 1 RDV pris.`,
      },
      // Bob - Immeuble 2
      {
        dateProspection: new Date(date.setDate(2)),
        commercialId: commercialBob.id,
        immeubleId: immeuble2.id,
        nbPortesVisitees: 4 + i, nbContratsSignes: 2 + i, nbRdvPris: 0, nbRefus: 1, nbAbsents: 1,
        commentaire: `Bonne journée mois ${i}, 2 contrats.`,
      },
      // Charlie - Immeuble 3
      {
        dateProspection: new Date(date.setDate(3)),
        commercialId: commercialCharlie.id,
        immeubleId: immeuble3.id,
        nbPortesVisitees: 5 + i, nbContratsSignes: 1 + i, nbRdvPris: 2, nbRefus: 1, nbAbsents: 1,
        commentaire: `Nouveau secteur mois ${i}, 1 contrat et 2 RDV.`,
      },
      // Diana - Immeuble 4
      {
        dateProspection: new Date(date.setDate(4)),
        commercialId: commercialDiana.id,
        immeubleId: immeuble4.id,
        nbPortesVisitees: 3 + i, nbContratsSignes: 1 + i, nbRdvPris: 0, nbRefus: 0, nbAbsents: 2,
        commentaire: `Bonne prise de contact mois ${i}.`,
      }
    );
  }

  await prisma.historiqueProspection.createMany({
    data: historicalEntries,
    skipDuplicates: true,
  });
  console.log(`Created historique prospection entries.`);

  console.log(`Seeding finished.`);
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


# --- src/statistics/statistics.service.ts ---
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import {
  PorteStatut,
  PeriodType,
  StatEntityType,
  HistoriqueProspection,
  Commercial,
  Prisma,
} from '@prisma/client';

@Injectable()
export class StatisticsService {
  constructor(private prisma: PrismaService) {}

  async getProspectingHistoryForCommercial(commercialId: string) {
    const historyEntries = await this.prisma.historiqueProspection.findMany({
      where: {
        commercialId: commercialId,
      },
      include: {
        immeuble: true, // Include related Immeuble data
      },
      orderBy: {
        dateProspection: 'desc',
      },
    });

    if (!historyEntries.length) {
      return [];
    }

    return historyEntries.map((entry) => ({
      id: entry.id,
      adresse: entry.immeuble.adresse,
      ville: entry.immeuble.ville,
      dateProspection: entry.dateProspection,
      nbPortesVisitees: entry.nbPortesVisitees,
      nbContratsSignes: entry.nbContratsSignes,
      nbRdvPris: entry.nbRdvPris,
      nbRefus: entry.nbRefus,
      nbAbsents: entry.nbAbsents,
      commentaire: entry.commentaire,
      // Calculate tauxCouverture based on nbPortesVisitees and immeuble.nbPortesTotal
      tauxCouverture:
        entry.immeuble.nbPortesTotal > 0
          ? Math.min(
              (entry.nbPortesVisitees / entry.immeuble.nbPortesTotal) * 100,
              100,
            )
          : 0,
    }));
  }

  async getStatsForCommercial(commercialId: string) {
    const commercial = await this.prisma.commercial.findUnique({
      where: { id: commercialId },
      include: {
        historiques: true,
      },
    });

    if (!commercial) {
      throw new NotFoundException(
        `Commercial with ID ${commercialId} not found`,
      );
    }

    const aggregatedStats = commercial.historiques.reduce(
      (acc, history) => {
        acc.immeublesVisites.add(history.immeubleId);
        acc.portesVisitees += history.nbPortesVisitees;
        acc.contratsSignes += history.nbContratsSignes;
        acc.rdvPris += history.nbRdvPris;
        acc.refus += history.nbRefus;
        acc.absents += history.nbAbsents;
        return acc;
      },
      {
        immeublesVisites: new Set<string>(),
        portesVisitees: 0,
        contratsSignes: 0,
        rdvPris: 0,
        refus: 0,
        absents: 0,
      },
    );

    const tauxDeConversion =
      aggregatedStats.portesVisitees > 0
        ? (aggregatedStats.contratsSignes / aggregatedStats.portesVisitees) *
          100
        : 0;

    const repartitionStatuts = {
      [PorteStatut.CONTRAT_SIGNE]: aggregatedStats.contratsSignes,
      [PorteStatut.REFUS]: aggregatedStats.refus,
      [PorteStatut.ABSENT]: aggregatedStats.absents,
    };

    return {
      commercialInfo: {
        nom: commercial.nom,
        prenom: commercial.prenom,
        email: commercial.email,
      },
      kpis: {
        immeublesVisites: aggregatedStats.immeublesVisites.size,
        portesVisitees: aggregatedStats.portesVisitees,
        contratsSignes: aggregatedStats.contratsSignes,
        rdvPris: aggregatedStats.rdvPris,
        tauxDeConversion: parseFloat(
          Math.min(tauxDeConversion, 100).toFixed(2),
        ),
      },
      repartitionStatuts,
    };
  }

  async getStatsForManager(managerId: string) {
    const managerWithEquipesAndCommerciaux =
      await this.prisma.manager.findUnique({
        where: { id: managerId },
        include: {
          equipes: {
            include: {
              commerciaux: {
                include: {
                  historiques: true,
                },
              },
            },
          },
        },
      });

    if (!managerWithEquipesAndCommerciaux) {
      throw new NotFoundException(`Manager with ID ${managerId} not found`);
    }

    const commercials = managerWithEquipesAndCommerciaux.equipes.flatMap(
      (equipe) => equipe.commerciaux,
    );

    if (!commercials.length) {
      return {
        kpis: {
          contratsSignes: 0,
          rdvPris: 0,
          tauxConclusion: 0,
        },
      };
    }

    const stats = commercials.reduce(
      (acc, commercial) => {
        const commercialStats = commercial.historiques.reduce(
          (commAcc, h) => {
            commAcc.contratsSignes += h.nbContratsSignes;
            commAcc.rdvPris += h.nbRdvPris;
            return commAcc;
          },
          { contratsSignes: 0, rdvPris: 0 },
        );
        acc.totalContratsSignes += commercialStats.contratsSignes;
        acc.totalRdvPris += commercialStats.rdvPris;
        return acc;
      },
      { totalContratsSignes: 0, totalRdvPris: 0 },
    );

    const tauxConclusion =
      stats.totalRdvPris > 0
        ? (stats.totalContratsSignes / stats.totalRdvPris) * 100
        : 0;

    return {
      contratsSignes: stats.totalContratsSignes,
      rdvPris: stats.totalRdvPris,
      tauxConclusion: parseFloat(tauxConclusion.toFixed(2)),
    };
  }

  async getManagerPerformanceHistory(managerId: string) {
    const histories = await this.prisma.historiqueProspection.findMany({
      where: {
        commercial: {
          equipe: {
            managerId: managerId,
          },
        },
      },
      orderBy: {
        dateProspection: 'asc',
      },
    });

    const monthlyStats = new Map<string, { contrats: number; rdv: number }>();

    histories.forEach((h) => {
      const month = h.dateProspection.toISOString().substring(0, 7); // YYYY-MM
      if (!monthlyStats.has(month)) {
        monthlyStats.set(month, { contrats: 0, rdv: 0 });
      }
      const current = monthlyStats.get(month)!;
      current.contrats += h.nbContratsSignes;
      current.rdv += h.nbRdvPris;
    });

    const perfHistory = Array.from(monthlyStats.entries())
      .sort(([monthA], [monthB]) => monthA.localeCompare(monthB))
      .map(([month, data]) => ({
        name: month,
        performance: data.rdv > 0 ? (data.contrats / data.rdv) * 100 : 0,
      }));

    return perfHistory;
  }

  async getStatistics(
    period: PeriodType,
    entityType?: StatEntityType,
    entityId?: string,
  ) {
    const getStartDate = (period: PeriodType) => {
      const now = new Date();
      if (period === 'WEEKLY') {
        const dayOfWeek = now.getDay();
        const diff = now.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
        return new Date(now.setDate(diff));
      } else if (period === 'MONTHLY') {
        return new Date(now.getFullYear(), now.getMonth(), 1);
      } else if (period === 'YEARLY') {
        return new Date(now.getFullYear(), 0, 1);
      }
      return undefined; // Should not happen with enum validation
    };

    const startDate = getStartDate(period);

    const whereConditions: Prisma.HistoriqueProspectionWhereInput = {
      dateProspection: {
        gte: startDate,
      },
    };

    if (entityId && entityType) {
      switch (entityType) {
        case 'COMMERCIAL':
          whereConditions.commercialId = entityId;
          break;
        case 'EQUIPE':
          whereConditions.commercial = { equipeId: entityId };
          break;
        case 'MANAGER':
          whereConditions.commercial = { equipe: { managerId: entityId } };
          break;
      }
    }

    const historiques: (HistoriqueProspection & { commercial: Commercial })[] =
      await this.prisma.historiqueProspection.findMany({
        where: whereConditions,
        include: {
          commercial: true,
        },
        orderBy: {
          dateProspection: 'asc',
        },
      });

    const stats = historiques.reduce(
      (acc, h) => {
        acc.totalContratsSignes += h.nbContratsSignes;
        acc.totalRdvPris += h.nbRdvPris;
        acc.totalPortesVisitees += h.nbPortesVisitees;
        acc.totalRefus += h.nbRefus;
        acc.totalAbsents += h.nbAbsents;
        return acc;
      },
      {
        totalContratsSignes: 0,
        totalRdvPris: 0,
        totalPortesVisitees: 0,
        totalRefus: 0,
        totalAbsents: 0,
      },
    );

    const tauxDeConversion =
      stats.totalPortesVisitees > 0
        ? (stats.totalContratsSignes / stats.totalPortesVisitees) * 100
        : 0;

    const performanceHistory = this.calculatePerformanceHistory(
      historiques,
      period,
    );
    const repartitionStatuts = {
      'Contrats Signés': stats.totalContratsSignes,
      Refus: stats.totalRefus,
      Absents: stats.totalAbsents,
    };

    return {
      kpis: {
        totalContratsSignes: stats.totalContratsSignes,
        totalRdvPris: stats.totalRdvPris,
        totalPortesVisitees: stats.totalPortesVisitees,
        tauxDeConversion: parseFloat(tauxDeConversion.toFixed(2)),
      },
      performanceHistory,
      repartitionStatuts,
    };
  }

  private calculatePerformanceHistory(
    historiques: HistoriqueProspection[],
    period: PeriodType,
  ) {
    const formatKey = (date: Date) => {
      if (period === 'WEEKLY') {
        const startOfWeek = new Date(date);
        startOfWeek.setDate(date.getDate() - date.getDay() + 1);
        return startOfWeek.toISOString().substring(0, 10);
      } else if (period === 'MONTHLY') {
        return date.toISOString().substring(0, 7); // YYYY-MM
      } else {
        // YEARLY
        return date.getFullYear().toString();
      }
    };

    const aggregated = new Map<string, { contrats: number; rdv: number }>();

    historiques.forEach((h) => {
      const key = formatKey(h.dateProspection);
      if (!aggregated.has(key)) {
        aggregated.set(key, { contrats: 0, rdv: 0 });
      }
      const current = aggregated.get(key)!;
      current.contrats += h.nbContratsSignes;
      current.rdv += h.nbRdvPris;
    });

    return Array.from(aggregated.entries())
      .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
      .map(([name, data]) => ({
        name,
        performance: data.rdv > 0 ? (data.contrats / data.rdv) * 100 : 0,
      }));
  }
}



# --- README.md ---
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).



# --- src/equipe/equipe.service.ts ---
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateEquipeDto } from './dto/create-equipe.dto';
import { UpdateEquipeDto } from './dto/update-equipe.dto';

@Injectable()
export class EquipeService {
  constructor(private prisma: PrismaService) {}

  create(createEquipeDto: CreateEquipeDto) {
    return this.prisma.equipe.create({ data: createEquipeDto });
  }

  findAll() {
    return this.prisma.equipe.findMany({
      include: {
        manager: true,
        commerciaux: {
          include: {
            historiques: true,
          },
        },
      },
    });
  }

  findOne(id: string) {
    return this.prisma.equipe.findUnique({
      where: { id },
      include: { manager: true, commerciaux: true },
    });
  }

  async getEquipeDetails(equipeId: string) {
    const equipe = await this.prisma.equipe.findUnique({
      where: { id: equipeId },
      include: {
        manager: true,
        commerciaux: {
          include: {
            historiques: true,
          },
        },
      },
    });

    if (!equipe) {
      throw new NotFoundException(`Equipe with ID ${equipeId} not found`);
    }

    // 1. Calcul des KPIs de l'équipe
    const equipeStats = equipe.commerciaux.reduce(
      (acc, commercial) => {
        commercial.historiques.forEach((h) => {
          acc.contratsSignes += h.nbContratsSignes;
          acc.rdvPris += h.nbRdvPris;
          acc.portesVisitees += h.nbPortesVisitees;
        });
        return acc;
      },
      { contratsSignes: 0, rdvPris: 0, portesVisitees: 0 },
    );

    const perfMoyenne =
      equipeStats.portesVisitees > 0
        ? (equipeStats.contratsSignes / equipeStats.portesVisitees) * 100
        : 0;

    // 2. Classement des commerciaux au sein de l'équipe
    const commerciauxAvecStats = equipe.commerciaux
      .map((c) => {
        const totalContrats = c.historiques.reduce(
          (sum, h) => sum + h.nbContratsSignes,
          0,
        );
        return { ...c, totalContrats };
      })
      .sort((a, b) => b.totalContrats - a.totalContrats);

    const commerciauxClasses = commerciauxAvecStats.map((c, index) => ({
      id: c.id,
      nom: c.nom,
      prenom: c.prenom,
      email: c.email,
      classement: index + 1,
    }));

    // 3. Historique de performance de l'équipe (par semaine, exemple)
    const weeklyStats = new Map<string, { contrats: number; portes: number }>();
    equipe.commerciaux.forEach((c) => {
      c.historiques.forEach((h) => {
        const weekStart = this.getStartOfWeek(h.dateProspection)
          .toISOString()
          .substring(0, 10);
        if (!weeklyStats.has(weekStart)) {
          weeklyStats.set(weekStart, { contrats: 0, portes: 0 });
        }
        const current = weeklyStats.get(weekStart)!;
        current.contrats += h.nbContratsSignes;
        current.portes += h.nbPortesVisitees;
      });
    });

    const perfHistory = Array.from(weeklyStats.entries())
      .sort(
        ([dateA], [dateB]) =>
          new Date(dateA).getTime() - new Date(dateB).getTime(),
      )
      .map(([week, data]) => ({
        name: `S - ${week}`,
        perf: data.portes > 0 ? (data.contrats / data.portes) * 100 : 0,
      }));

    // 4. Classement général de l'équipe
    const toutesLesEquipes = await this.prisma.equipe.findMany({
      include: { commerciaux: { include: { historiques: true } } },
    });

    const equipesAvecContrats = toutesLesEquipes
      .map((e) => {
        const totalContrats = e.commerciaux.reduce(
          (sum, c) =>
            sum + c.historiques.reduce((s, h) => s + h.nbContratsSignes, 0),
          0,
        );
        return { id: e.id, totalContrats };
      })
      .sort((a, b) => b.totalContrats - a.totalContrats);

    const classementGeneral =
      equipesAvecContrats.findIndex((e) => e.id === equipeId) + 1;

    return {
      id: equipe.id,
      nom: equipe.nom,
      manager: `${equipe.manager.prenom} ${equipe.manager.nom}`,
      stats: {
        contratsSignes: equipeStats.contratsSignes,
        rdvPris: equipeStats.rdvPris,
        perfMoyenne: parseFloat(perfMoyenne.toFixed(2)),
        classementGeneral: classementGeneral > 0 ? classementGeneral : 'N/A',
        nbCommerciaux: equipe.commerciaux.length,
      },
      perfHistory,
      commerciaux: commerciauxClasses,
    };
  }

  private getStartOfWeek(d: Date): Date {
    const date = new Date(d);
    const day = date.getDay();
    const diff = date.getDate() - day + (day === 0 ? -6 : 1); // adjust when day is sunday
    return new Date(date.setDate(diff));
  }

  update(id: string, updateEquipeDto: UpdateEquipeDto) {
    return this.prisma.equipe.update({ where: { id }, data: updateEquipeDto });
  }

  remove(id: string) {
    return this.prisma.equipe.delete({ where: { id } });
  }
}



# --- src/assignment-goals/assignment-goals.service.ts ---
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { AssignmentType } from '@prisma/client';

@Injectable()
export class AssignmentGoalsService {
  constructor(private prisma: PrismaService) {}

  async assignZone(
    zoneId: string,
    assigneeId: string,
    assignmentType: AssignmentType,
  ) {
    const zone = await this.prisma.zone.findUnique({ where: { id: zoneId } });
    if (!zone) {
      throw new NotFoundException(`Zone with ID ${zoneId} not found`);
    }

    const updateData: {
      typeAssignation: AssignmentType;
      equipeId: string | null;
      managerId: string | null;
      commercialId: string | null;
    } = {
      typeAssignation: assignmentType,
      equipeId: null,
      managerId: null,
      commercialId: null,
    };

    switch (assignmentType) {
      case AssignmentType.EQUIPE: {
        const equipe = await this.prisma.equipe.findUnique({
          where: { id: assigneeId },
        });
        if (!equipe)
          throw new NotFoundException(`Equipe with ID ${assigneeId} not found`);
        updateData.equipeId = assigneeId;
        break;
      }
      case AssignmentType.MANAGER: {
        const manager = await this.prisma.manager.findUnique({
          where: { id: assigneeId },
        });
        if (!manager)
          throw new NotFoundException(
            `Manager with ID ${assigneeId} not found`,
          );
        updateData.managerId = assigneeId;
        break;
      }
      case AssignmentType.COMMERCIAL: {
        const commercial = await this.prisma.commercial.findUnique({
          where: { id: assigneeId },
        });
        if (!commercial)
          throw new NotFoundException(
            `Commercial with ID ${assigneeId} not found`,
          );
        updateData.commercialId = assigneeId;
        break;
      }
      default:
        throw new BadRequestException('Invalid assignment type');
    }

    return this.prisma.zone.update({
      where: { id: zoneId },
      data: updateData,
    });
  }

  async setMonthlyGoal(commercialId: string, goal: number) {
    const commercial = await this.prisma.commercial.findUnique({
      where: { id: commercialId },
    });
    if (!commercial) {
      throw new NotFoundException(
        `Commercial with ID ${commercialId} not found`,
      );
    }

    return this.prisma.commercial.update({
      where: { id: commercialId },
      data: { currentMonthlyGoal: goal },
    });
  }

  async getAssignedZonesForManager(managerId: string) {
    return this.prisma.zone.findMany({
      where: { managerId: managerId },
      include: { commercial: true, equipe: true },
    });
  }

  async getAssignedZonesForCommercial(commercialId: string) {
    return this.prisma.zone.findMany({
      where: { commercialId: commercialId },
      include: { manager: true, equipe: true },
    });
  }

  async getCommercialsInZone(zoneId: string) {
    const zone = await this.prisma.zone.findUnique({
      where: { id: zoneId },
      include: {
        commercial: true, // Si la zone est directement assignée à un commercial
        equipe: { include: { commerciaux: true } }, // Si la zone est assignée à une équipe, récupérer ses commerciaux
      },
    });

    if (!zone) {
      throw new NotFoundException(`Zone with ID ${zoneId} not found`);
    }

    if (zone.commercial) {
      return [zone.commercial];
    } else if (zone.equipe && zone.equipe.commerciaux) {
      return zone.equipe.commerciaux;
    }
    return [];
  }
}



# --- package.json ---
{
  "name": "backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "postinstall": "npx prisma generate",
    "seed": "ts-node prisma/seed.ts"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.1",
    "@nestjs/core": "^11.0.1",
    "@nestjs/mapped-types": "^2.1.0",
    "@nestjs/platform-express": "^11.0.1",
    "@prisma/client": "^6.11.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "dotenv": "^17.0.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@swc/cli": "^0.6.0",
    "@swc/core": "^1.10.7",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^29.7.0",
    "prettier": "^3.6.2",
    "prisma": "^6.11.1",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



# --- src/immeuble/immeuble.service.ts ---
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateImmeubleDto } from './dto/create-immeuble.dto';
import { UpdateImmeubleDto } from './dto/update-immeuble.dto';

@Injectable()
export class ImmeubleService {
  constructor(private prisma: PrismaService) {}

  create(createImmeubleDto: CreateImmeubleDto) {
    return this.prisma.immeuble.create({ data: createImmeubleDto });
  }

  findAll() {
    return this.prisma.immeuble.findMany({
      include: { zone: true, prospectors: true },
    });
  }

  findOne(id: string) {
    return this.prisma.immeuble.findUnique({
      where: { id },
      include: { zone: true, prospectors: true, portes: true },
    });
  }

  async getImmeubleDetails(immeubleId: string) {
    const immeuble = await this.prisma.immeuble.findUnique({
      where: { id: immeubleId },
      include: {
        prospectors: true,
        portes: true,
        historiques: true,
        zone: true,
      },
    });

    if (!immeuble) {
      throw new NotFoundException(`Immeuble with ID ${immeubleId} not found`);
    }

    const stats = immeuble.historiques.reduce(
      (acc, h) => {
        acc.contratsSignes += h.nbContratsSignes;
        acc.rdvPris += h.nbRdvPris;
        return acc;
      },
      { contratsSignes: 0, rdvPris: 0 },
    );

    const portesAffichees = immeuble.portes;
    if (immeuble.prospectingMode === 'SOLO') {
      // Pour SOLO, on ne filtre que sur le papier, mais on les affiche toutes
      // La logique de filtrage pair/impair sera sur le front si nécessaire
    } else if (immeuble.prospectingMode === 'DUO') {
      // Aucune filtration spécifique ici, on les affiche toutes
    }

    return {
      ...immeuble,
      stats,
      portes: portesAffichees,
    };
  }

  update(id: string, updateImmeubleDto: UpdateImmeubleDto) {
    return this.prisma.immeuble.update({
      where: { id },
      data: updateImmeubleDto,
    });
  }

  remove(id: string) {
    return this.prisma.immeuble.delete({ where: { id } });
  }
}



# --- src/zone/zone.service.ts ---
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateZoneDto } from './dto/create-zone.dto';
import { UpdateZoneDto } from './dto/update-zone.dto';

@Injectable()
export class ZoneService {
  constructor(private prisma: PrismaService) {}

  create(createZoneDto: CreateZoneDto) {
    return this.prisma.zone.create({ data: createZoneDto });
  }

  findAll() {
    return this.prisma.zone.findMany({
      include: { equipe: true, manager: true, commercial: true },
    });
  }

  findOne(id: string) {
    return this.prisma.zone.findUnique({
      where: { id },
      include: { equipe: true, manager: true, commercial: true },
    });
  }

  async getZoneDetails(zoneId: string) {
    const zone = await this.prisma.zone.findUnique({
      where: { id: zoneId },
      include: {
        immeubles: {
          include: {
            historiques: true,
            prospectors: true,
          },
        },
        equipe: true,
        manager: true,
        commercial: true,
      },
    });

    if (!zone) {
      throw new NotFoundException(`Zone with ID ${zoneId} not found`);
    }

    const stats = zone.immeubles.reduce(
      (acc, immeuble) => {
        acc.nbImmeubles++;
        const immeubleStats = immeuble.historiques.reduce(
          (iAcc, h) => {
            iAcc.contratsSignes += h.nbContratsSignes;
            iAcc.rdvPris += h.nbRdvPris;
            return iAcc;
          },
          { contratsSignes: 0, rdvPris: 0 },
        );
        acc.totalContratsSignes += immeubleStats.contratsSignes;
        acc.totalRdvPris += immeubleStats.rdvPris;
        return acc;
      },
      { nbImmeubles: 0, totalContratsSignes: 0, totalRdvPris: 0 },
    );

    return {
      ...zone,
      stats,
    };
  }

  update(id: string, updateZoneDto: UpdateZoneDto) {
    return this.prisma.zone.update({ where: { id }, data: updateZoneDto });
  }

  remove(id: string) {
    return this.prisma.zone.delete({ where: { id } });
  }
}



# --- send_to_gemini.py ---
import os

EXCLUDED_DIRS = {"node_modules", ".git", ".next", ".turbo", "dist", "build"}
TEXT_EXTENSIONS = {'.ts', '.tsx', '.js', '.jsx', '.json', '.html', '.css', '.md', '.txt', '.py'}

def get_all_files(root_dir):
    result = []

    for foldername, _, filenames in os.walk(root_dir):
        if any(excluded in foldername for excluded in EXCLUDED_DIRS):
            continue

        for filename in filenames:
            filepath = os.path.join(foldername, filename)
            ext = os.path.splitext(filename)[1].lower()
            if ext in TEXT_EXTENSIONS:
                result.append(filepath)

    return result

def read_file_content(filepath):
    try:
        with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except:
        return ""

def export_balanced_parts(root_dir, output_base="code_part"):
    all_files = get_all_files(root_dir)

    # Lire tous les fichiers avec leur contenu
    file_entries = []
    for path in all_files:
        content = read_file_content(path)
        relative_path = os.path.relpath(path, root_dir)
        wrapped_content = f"\n\n# --- {relative_path} ---\n{content}\n"
        file_entries.append((relative_path, wrapped_content, len(wrapped_content)))

    # Trier les fichiers par taille (descendant)
    file_entries.sort(key=lambda x: x[2], reverse=True)

    part1, part2 = [], []
    size1, size2 = 0, 0

    for _, content, size in file_entries:
        if size1 <= size2:
            part1.append(content)
            size1 += size
        else:
            part2.append(content)
            size2 += size

    with open(f"{output_base}1.txt", "w", encoding="utf-8") as f1:
        f1.writelines(part1)

    with open(f"{output_base}2.txt", "w", encoding="utf-8") as f2:
        f2.writelines(part2)

    print(f"✅ Fichiers générés : {output_base}1.txt ({size1} car.), {output_base}2.txt ({size2} car.)")

if __name__ == "__main__":
    export_balanced_parts("./")



# --- src/assignment-goals/assignment-goals.controller.ts ---
import { Controller, Post, Body, Get, Param } from '@nestjs/common';
import { AssignmentGoalsService } from './assignment-goals.service';
import { AssignmentType } from '@prisma/client';

@Controller('assignment-goals')
export class AssignmentGoalsController {
  constructor(
    private readonly assignmentGoalsService: AssignmentGoalsService,
  ) {}

  @Post('assign-zone')
  assignZone(
    @Body('zoneId') zoneId: string,
    @Body('assigneeId') assigneeId: string,
    @Body('assignmentType') assignmentType: AssignmentType,
  ) {
    return this.assignmentGoalsService.assignZone(
      zoneId,
      assigneeId,
      assignmentType,
    );
  }

  @Post('set-monthly-goal')
  setMonthlyGoal(
    @Body('commercialId') commercialId: string,
    @Body('goal') goal: number,
  ) {
    return this.assignmentGoalsService.setMonthlyGoal(commercialId, goal);
  }

  @Get('manager/:managerId/zones')
  getAssignedZonesForManager(@Param('managerId') managerId: string) {
    return this.assignmentGoalsService.getAssignedZonesForManager(managerId);
  }

  @Get('commercial/:commercialId/zones')
  getAssignedZonesForCommercial(@Param('commercialId') commercialId: string) {
    return this.assignmentGoalsService.getAssignedZonesForCommercial(
      commercialId,
    );
  }

  @Get('zone/:zoneId/commercials')
  getCommercialsInZone(@Param('zoneId') zoneId: string) {
    return this.assignmentGoalsService.getCommercialsInZone(zoneId);
  }
}



# --- src/statistics/statistics.controller.ts ---
import { Controller, Get, Query, Param } from '@nestjs/common';
import { StatisticsService } from './statistics.service';
import { PeriodType, StatEntityType } from '@prisma/client';

@Controller('statistics')
export class StatisticsController {
  constructor(private readonly statisticsService: StatisticsService) {}

  @Get('commercial/:id/history')
  getCommercialHistory(@Param('id') id: string) {
    return this.statisticsService.getProspectingHistoryForCommercial(id);
  }

  @Get('commercial/:id')
  getCommercialStats(@Param('id') id: string) {
    return this.statisticsService.getStatsForCommercial(id);
  }

  @Get('manager/:id')
  getManagerStats(@Param('id') id: string) {
    return this.statisticsService.getStatsForManager(id);
  }

  @Get('manager/:id/history')
  getManagerPerformanceHistory(@Param('id') id: string) {
    return this.statisticsService.getManagerPerformanceHistory(id);
  }

  @Get()
  getStatistics(
    @Query('period') period: PeriodType,
    @Query('entityType') entityType?: StatEntityType,
    @Query('entityId') entityId?: string,
  ) {
    return this.statisticsService.getStatistics(period, entityType, entityId);
  }
}



# --- src/commercial/commercial.service.ts ---
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateCommercialDto } from './dto/create-commercial.dto';
import { UpdateCommercialDto } from './dto/update-commercial.dto';

@Injectable()
export class CommercialService {
  constructor(private prisma: PrismaService) {}

  create(createCommercialDto: CreateCommercialDto) {
    return this.prisma.commercial.create({ data: createCommercialDto });
  }

  findAll() {
    return this.prisma.commercial.findMany({
      include: {
        equipe: {
          include: {
            manager: true,
          },
        },
        historiques: true, // Include historiques to sum contracts
      },
    });
  }

  findOne(id: string) {
    return this.prisma.commercial.findUnique({
      where: { id },
      include: { equipe: { include: { manager: true } } },
    });
  }

  update(id: string, updateCommercialDto: UpdateCommercialDto) {
    return this.prisma.commercial.update({
      where: { id },
      data: updateCommercialDto,
    });
  }

  remove(id: string) {
    return this.prisma.commercial.delete({ where: { id } });
  }
}



# --- src/manager/manager.service.ts ---
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateManagerDto } from './dto/create-manager.dto';
import { UpdateManagerDto } from './dto/update-manager.dto';

@Injectable()
export class ManagerService {
  constructor(private prisma: PrismaService) {}

  create(createManagerDto: CreateManagerDto) {
    return this.prisma.manager.create({ data: createManagerDto });
  }

  findAll() {
    return this.prisma.manager.findMany({
      include: {
        equipes: {
          include: {
            commerciaux: {
              include: {
                historiques: true,
              },
            },
          },
        },
      },
    });
  }

  findOne(id: string) {
    return this.prisma.manager.findUnique({
      where: { id },
      include: { equipes: { include: { commerciaux: true } } },
    });
  }

  update(id: string, updateManagerDto: UpdateManagerDto) {
    return this.prisma.manager.update({
      where: { id },
      data: updateManagerDto,
    });
  }

  remove(id: string) {
    return this.prisma.manager.delete({ where: { id } });
  }
}



# --- src/immeuble/immeuble.controller.ts ---
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { ImmeubleService } from './immeuble.service';
import { CreateImmeubleDto } from './dto/create-immeuble.dto';
import { UpdateImmeubleDto } from './dto/update-immeuble.dto';

@Controller('immeubles')
export class ImmeubleController {
  constructor(private readonly immeubleService: ImmeubleService) {}

  @Post()
  create(@Body() createImmeubleDto: CreateImmeubleDto) {
    return this.immeubleService.create(createImmeubleDto);
  }

  @Get()
  findAll() {
    return this.immeubleService.findAll();
  }

  @Get(':id/details')
  getImmeubleDetails(@Param('id') id: string) {
    return this.immeubleService.getImmeubleDetails(id);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.immeubleService.findOne(id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateImmeubleDto: UpdateImmeubleDto,
  ) {
    return this.immeubleService.update(id, updateImmeubleDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.immeubleService.remove(id);
  }
}



# --- src/equipe/equipe.controller.ts ---
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { EquipeService } from './equipe.service';
import { CreateEquipeDto } from './dto/create-equipe.dto';
import { UpdateEquipeDto } from './dto/update-equipe.dto';

@Controller('equipes')
export class EquipeController {
  constructor(private readonly equipeService: EquipeService) {}

  @Post()
  create(@Body() createEquipeDto: CreateEquipeDto) {
    return this.equipeService.create(createEquipeDto);
  }

  @Get()
  findAll() {
    return this.equipeService.findAll();
  }

  @Get(':id/details')
  getEquipeDetails(@Param('id') id: string) {
    return this.equipeService.getEquipeDetails(id);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.equipeService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateEquipeDto: UpdateEquipeDto) {
    return this.equipeService.update(id, updateEquipeDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.equipeService.remove(id);
  }
}



# --- src/commercial/commercial.controller.ts ---
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { CommercialService } from './commercial.service';
import { CreateCommercialDto } from './dto/create-commercial.dto';
import { UpdateCommercialDto } from './dto/update-commercial.dto';

@Controller('commerciaux')
export class CommercialController {
  constructor(private readonly commercialService: CommercialService) {}

  @Post()
  create(@Body() createCommercialDto: CreateCommercialDto) {
    return this.commercialService.create(createCommercialDto);
  }

  @Get()
  findAll() {
    return this.commercialService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.commercialService.findOne(id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateCommercialDto: UpdateCommercialDto,
  ) {
    return this.commercialService.update(id, updateCommercialDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.commercialService.remove(id);
  }
}



# --- src/zone/zone.controller.ts ---
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { ZoneService } from './zone.service';
import { CreateZoneDto } from './dto/create-zone.dto';
import { UpdateZoneDto } from './dto/update-zone.dto';

@Controller('zones')
export class ZoneController {
  constructor(private readonly zoneService: ZoneService) {}

  @Post()
  create(@Body() createZoneDto: CreateZoneDto) {
    return this.zoneService.create(createZoneDto);
  }

  @Get()
  findAll() {
    return this.zoneService.findAll();
  }

  @Get(':id/details')
  getZoneDetails(@Param('id') id: string) {
    return this.zoneService.getZoneDetails(id);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.zoneService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateZoneDto: UpdateZoneDto) {
    return this.zoneService.update(id, updateZoneDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.zoneService.remove(id);
  }
}



# --- src/immeuble/dto/create-immeuble.dto.ts ---
import { ImmeubleStatus, ProspectingMode } from '@prisma/client';
import { IsString, IsNotEmpty, IsOptional, IsEnum, IsNumber, IsDate, IsBoolean, IsArray } from 'class-validator';

export class CreateImmeubleDto {
  @IsString()
  @IsNotEmpty()
  adresse: string;

  @IsString()
  @IsNotEmpty()
  ville: string;

  @IsString()
  @IsNotEmpty()
  codePostal: string;

  @IsEnum(ImmeubleStatus)
  @IsOptional()
  status?: ImmeubleStatus;

  @IsNumber()
  @IsNotEmpty()
  nbPortesTotal: number;

  @IsEnum(ProspectingMode)
  @IsNotEmpty()
  prospectingMode: ProspectingMode;

  @IsDate()
  @IsOptional()
  dateDerniereVisite?: Date;

  @IsString()
  @IsNotEmpty()
  zoneId: string;

  @IsNumber()
  @IsNotEmpty()
  latitude: number;

  @IsNumber()
  @IsNotEmpty()
  longitude: number;

  @IsBoolean()
  @IsNotEmpty()
  hasElevator: boolean;

  @IsString()
  @IsOptional()
  digicode?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  prospectorsIds?: string[];
}



# --- src/app.module.ts ---
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { ManagerModule } from './manager/manager.module';
import { EquipeModule } from './equipe/equipe.module';
import { CommercialModule } from './commercial/commercial.module';
import { ZoneModule } from './zone/zone.module';
import { ImmeubleModule } from './immeuble/immeuble.module';
import { PorteModule } from './porte/porte.module';
import { StatisticsModule } from './statistics/statistics.module';
import { AssignmentGoalsModule } from './assignment-goals/assignment-goals.module';

@Module({
  imports: [
    PrismaModule,
    ManagerModule,
    EquipeModule,
    CommercialModule,
    ZoneModule,
    ImmeubleModule,
    PorteModule,
    StatisticsModule,
    AssignmentGoalsModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}



# --- src/manager/manager.controller.ts ---
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { ManagerService } from './manager.service';
import { CreateManagerDto } from './dto/create-manager.dto';
import { UpdateManagerDto } from './dto/update-manager.dto';

@Controller('managers')
export class ManagerController {
  constructor(private readonly managerService: ManagerService) {}

  @Post()
  create(@Body() createManagerDto: CreateManagerDto) {
    return this.managerService.create(createManagerDto);
  }

  @Get()
  findAll() {
    return this.managerService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.managerService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateManagerDto: UpdateManagerDto) {
    return this.managerService.update(id, updateManagerDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.managerService.remove(id);
  }
}



# --- src/porte/porte.controller.ts ---
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { PorteService } from './porte.service';
import { CreatePorteDto } from './dto/create-porte.dto';
import { UpdatePorteDto } from './dto/update-porte.dto';

@Controller('portes')
export class PorteController {
  constructor(private readonly porteService: PorteService) {}

  @Post()
  create(@Body() createPorteDto: CreatePorteDto) {
    return this.porteService.create(createPorteDto);
  }

  @Get()
  findAll() {
    return this.porteService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.porteService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePorteDto: UpdatePorteDto) {
    return this.porteService.update(id, updatePorteDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.porteService.remove(id);
  }
}



# --- src/porte/porte.service.ts ---
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreatePorteDto } from './dto/create-porte.dto';
import { UpdatePorteDto } from './dto/update-porte.dto';

@Injectable()
export class PorteService {
  constructor(private prisma: PrismaService) {}

  create(createPorteDto: CreatePorteDto) {
    return this.prisma.porte.create({ data: createPorteDto });
  }

  findAll() {
    return this.prisma.porte.findMany();
  }

  findOne(id: string) {
    return this.prisma.porte.findUnique({ where: { id } });
  }

  update(id: string, updatePorteDto: UpdatePorteDto) {
    return this.prisma.porte.update({ where: { id }, data: updatePorteDto });
  }

  remove(id: string) {
    return this.prisma.porte.delete({ where: { id } });
  }
}



# --- src/zone/dto/create-zone.dto.ts ---
import { AssignmentType } from '@prisma/client';
import { IsEnum, IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';

export class CreateZoneDto {
  @IsString()
  @IsNotEmpty()
  nom: string;

  @IsNumber()
  @IsNotEmpty()
  latitude: number;

  @IsNumber()
  @IsNotEmpty()
  longitude: number;

  @IsNumber()
  @IsNotEmpty()
  rayonMetres: number;

  @IsString()
  @IsNotEmpty()
  couleur: string;

  @IsEnum(AssignmentType)
  @IsNotEmpty()
  typeAssignation: AssignmentType;

  @IsString()
  @IsOptional()
  equipeId?: string;

  @IsString()
  @IsOptional()
  managerId?: string;

  @IsString()
  @IsOptional()
  commercialId?: string;
}



# --- src/app.controller.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});



# --- src/main.ts ---
import 'dotenv/config';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalPipes(new ValidationPipe());

  app.enableCors({
    origin: 'http://localhost:5173',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    credentials: true,
  });

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap().catch((err: unknown) => {
  console.error(err);
  process.exit(1);
});



# --- tsconfig.json ---
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": true,
    "strictBindCallApply": true,
    "noFallthroughCasesInSwitch": true
  }
}



# --- src/prisma/prisma.service.ts ---
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }

  enableShutdownHooks(app: INestApplication) {
    this.$on('beforeExit' as never, () => {
      app
        .close()
        .then(() => {
          console.log('App closed');
        })
        .catch((err) => console.error(err));
    });
  }
}



# --- src/porte/dto/create-porte.dto.ts ---
import { PorteStatut } from '@prisma/client';
import { IsEnum, IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';

export class CreatePorteDto {
  @IsString()
  @IsNotEmpty()
  numeroPorte: string;

  @IsEnum(PorteStatut)
  @IsNotEmpty()
  statut: PorteStatut;

  @IsNumber()
  @IsNotEmpty()
  passage: number;

  @IsString()
  @IsOptional()
  commentaire?: string;

  @IsString()
  @IsNotEmpty()
  immeubleId: string;
}



# --- src/commercial/dto/create-commercial.dto.ts ---
import { IsEmail, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateCommercialDto {
  @IsString()
  @IsNotEmpty()
  nom: string;

  @IsString()
  @IsNotEmpty()
  prenom: string;

  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsOptional()
  telephone?: string;

  @IsString()
  @IsOptional()
  equipeId?: string;

  @IsString()
  @IsNotEmpty()
  managerId: string;
}



# --- src/assignment-goals/assignment-goals.module.ts ---
import { Module } from '@nestjs/common';
import { AssignmentGoalsService } from './assignment-goals.service';
import { AssignmentGoalsController } from './assignment-goals.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [AssignmentGoalsController],
  providers: [AssignmentGoalsService],
})
export class AssignmentGoalsModule {}



# --- src/statistics/statistics.module.ts ---
import { Module } from '@nestjs/common';
import { StatisticsService } from './statistics.service';
import { StatisticsController } from './statistics.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [StatisticsController],
  providers: [StatisticsService],
})
export class StatisticsModule {}



# --- src/commercial/commercial.module.ts ---
import { Module } from '@nestjs/common';
import { CommercialService } from './commercial.service';
import { CommercialController } from './commercial.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [CommercialController],
  providers: [CommercialService],
})
export class CommercialModule {}



# --- src/immeuble/immeuble.module.ts ---
import { Module } from '@nestjs/common';
import { ImmeubleService } from './immeuble.service';
import { ImmeubleController } from './immeuble.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [ImmeubleController],
  providers: [ImmeubleService],
})
export class ImmeubleModule {}



# --- src/manager/manager.module.ts ---
import { Module } from '@nestjs/common';
import { ManagerService } from './manager.service';
import { ManagerController } from './manager.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [ManagerController],
  providers: [ManagerService],
})
export class ManagerModule {}



# --- src/equipe/equipe.module.ts ---
import { Module } from '@nestjs/common';
import { EquipeService } from './equipe.service';
import { EquipeController } from './equipe.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [EquipeController],
  providers: [EquipeService],
})
export class EquipeModule {}



# --- src/porte/porte.module.ts ---
import { Module } from '@nestjs/common';
import { PorteService } from './porte.service';
import { PorteController } from './porte.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [PorteController],
  providers: [PorteService],
})
export class PorteModule {}



# --- src/zone/zone.module.ts ---
import { Module } from '@nestjs/common';
import { ZoneService } from './zone.service';
import { ZoneController } from './zone.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [ZoneController],
  providers: [ZoneService],
})
export class ZoneModule {}



# --- src/manager/dto/create-manager.dto.ts ---
import { IsEmail, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateManagerDto {
  @IsString()
  @IsNotEmpty()
  nom: string;

  @IsString()
  @IsNotEmpty()
  prenom: string;

  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsOptional()
  telephone?: string;
}



# --- src/app.controller.ts ---
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}



# --- src/commercial/dto/update-commercial.dto.ts ---
import { PartialType } from '@nestjs/mapped-types';
import { CreateCommercialDto } from './create-commercial.dto';

export class UpdateCommercialDto extends PartialType(CreateCommercialDto) {}



# --- src/immeuble/dto/update-immeuble.dto.ts ---
import { PartialType } from '@nestjs/mapped-types';
import { CreateImmeubleDto } from './create-immeuble.dto';

export class UpdateImmeubleDto extends PartialType(CreateImmeubleDto) {}



# --- src/equipe/dto/create-equipe.dto.ts ---
import { IsNotEmpty, IsString } from 'class-validator';

export class CreateEquipeDto {
  @IsString()
  @IsNotEmpty()
  nom: string;

  @IsString()
  @IsNotEmpty()
  managerId: string;
}



# --- src/prisma/prisma.module.ts ---
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}



# --- src/manager/dto/update-manager.dto.ts ---
import { PartialType } from '@nestjs/mapped-types';
import { CreateManagerDto } from './create-manager.dto';

export class UpdateManagerDto extends PartialType(CreateManagerDto) {}



# --- src/equipe/dto/update-equipe.dto.ts ---
import { PartialType } from '@nestjs/mapped-types';
import { CreateEquipeDto } from './create-equipe.dto';

export class UpdateEquipeDto extends PartialType(CreateEquipeDto) {}



# --- src/porte/dto/update-porte.dto.ts ---
import { PartialType } from '@nestjs/mapped-types';
import { CreatePorteDto } from './create-porte.dto';

export class UpdatePorteDto extends PartialType(CreatePorteDto) {}



# --- src/zone/dto/update-zone.dto.ts ---
import { PartialType } from '@nestjs/mapped-types';
import { CreateZoneDto } from './create-zone.dto';

export class UpdateZoneDto extends PartialType(CreateZoneDto) {}



# --- nest-cli.json ---
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}



# --- src/app.service.ts ---
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}



# --- tsconfig.build.json ---
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

