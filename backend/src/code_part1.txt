

# --- statistics/statistics.service.ts ---
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { PeriodType, StatEntityType, PorteStatut } from '@prisma/client';

@Injectable()
export class StatisticsService {
  constructor(private prisma: PrismaService) {}

  async getProspectingHistoryForCommercial(commercialId: string) {
    const historyEntries = await this.prisma.historiqueProspection.findMany({
      where: {
        commercialId: commercialId,
      },
      include: {
        immeuble: true, // Include related Immeuble data
      },
      orderBy: {
        dateProspection: 'desc',
      },
    });

    if (!historyEntries.length) {
      return [];
    }

    return historyEntries.map(entry => ({
      id: entry.id,
      adresse: entry.immeuble.adresse,
      ville: entry.immeuble.ville,
      dateProspection: entry.dateProspection,
      nbPortesVisitees: entry.nbPortesVisitees,
      nbContratsSignes: entry.nbContratsSignes,
      nbRdvPris: entry.nbRdvPris,
      nbRefus: entry.nbRefus,
      nbAbsents: entry.nbAbsents,
      commentaire: entry.commentaire,
      // Calculate tauxCouverture based on nbPortesVisitees and immeuble.nbPortesTotal
      tauxCouverture: entry.immeuble.nbPortesTotal > 0 ? Math.min((entry.nbPortesVisitees / entry.immeuble.nbPortesTotal) * 100, 100) : 0,
    }));
  }

  async getStatsForCommercial(commercialId: string) {
    const commercial = await this.prisma.commercial.findUnique({
      where: { id: commercialId },
      include: {
        historiques: true,
      },
    });

    if (!commercial) {
      throw new NotFoundException(`Commercial with ID ${commercialId} not found`);
    }

    const aggregatedStats = commercial.historiques.reduce(
      (acc, history) => {
        acc.immeublesVisites.add(history.immeubleId);
        acc.portesVisitees += history.nbPortesVisitees;
        acc.contratsSignes += history.nbContratsSignes;
        acc.rdvPris += history.nbRdvPris;
        acc.refus += history.nbRefus;
        acc.absents += history.nbAbsents;
        return acc;
      },
      {
        immeublesVisites: new Set<string>(),
        portesVisitees: 0,
        contratsSignes: 0,
        rdvPris: 0,
        refus: 0,
        absents: 0,
      },
    );

    const tauxDeConversion =
      aggregatedStats.portesVisitees > 0
        ? (aggregatedStats.contratsSignes / aggregatedStats.portesVisitees) * 100
        : 0;

    const repartitionStatuts = {
      [PorteStatut.CONTRAT_SIGNE]: aggregatedStats.contratsSignes,
      [PorteStatut.REFUS]: aggregatedStats.refus,
      [PorteStatut.ABSENT]: aggregatedStats.absents,
    };

    return {
      commercialInfo: {
        nom: commercial.nom,
        prenom: commercial.prenom,
        email: commercial.email,
      },
      kpis: {
        immeublesVisites: aggregatedStats.immeublesVisites.size,
        portesVisitees: aggregatedStats.portesVisitees,
        contratsSignes: aggregatedStats.contratsSignes,
        rdvPris: aggregatedStats.rdvPris,
        tauxDeConversion: parseFloat(Math.min(tauxDeConversion, 100).toFixed(2)),
      },
      repartitionStatuts,
    };
  }

  async getStatsForManager(managerId: string) {
    const managerWithEquipesAndCommerciaux = await this.prisma.manager.findUnique({
      where: { id: managerId },
      include: {
        equipes: {
          include: {
            commerciaux: {
              include: {
                historiques: true,
              },
            },
          },
        },
      },
    });

    if (!managerWithEquipesAndCommerciaux) {
      throw new NotFoundException(`Manager with ID ${managerId} not found`);
    }

    const commercials = managerWithEquipesAndCommerciaux.equipes.flatMap(
      (equipe) => equipe.commerciaux,
    );

    if (!commercials.length) {
      return {
        kpis: {
          contratsSignes: 0,
          rdvPris: 0,
          tauxConclusion: 0,
        },
      };
    }

    const stats = commercials.reduce(
      (acc, commercial) => {
        const commercialStats = commercial.historiques.reduce(
          (commAcc, h) => {
            commAcc.contratsSignes += h.nbContratsSignes;
            commAcc.rdvPris += h.nbRdvPris;
            return commAcc;
          },
          { contratsSignes: 0, rdvPris: 0 },
        );
        acc.totalContratsSignes += commercialStats.contratsSignes;
        acc.totalRdvPris += commercialStats.rdvPris;
        return acc;
      },
      { totalContratsSignes: 0, totalRdvPris: 0 },
    );

    const tauxConclusion =
      stats.totalRdvPris > 0
        ? (stats.totalContratsSignes / stats.totalRdvPris) * 100
        : 0;

    return {
      kpis: {
        contratsSignes: stats.totalContratsSignes,
        rdvPris: stats.totalRdvPris,
        tauxConclusion: parseFloat(tauxConclusion.toFixed(2)),
      },
    };
  }

  async getManagerPerformanceHistory(managerId: string) {
    const histories = await this.prisma.historiqueProspection.findMany({
      where: {
        commercial: {
          equipe: {
            managerId: managerId,
          },
        },
      },
      orderBy: {
        dateProspection: 'asc',
      },
    });

    const monthlyStats = new Map<string, { contrats: number; rdv: number }>();

    histories.forEach((h) => {
      const month = h.dateProspection.toISOString().substring(0, 7); // YYYY-MM
      if (!monthlyStats.has(month)) {
        monthlyStats.set(month, { contrats: 0, rdv: 0 });
      }
      const current = monthlyStats.get(month)!;
      current.contrats += h.nbContratsSignes;
      current.rdv += h.nbRdvPris;
    });

    const perfHistory = Array.from(monthlyStats.entries())
      .sort(([monthA], [monthB]) => monthA.localeCompare(monthB))
      .map(([month, data]) => ({
        name: month,
        perf: data.rdv > 0 ? (data.contrats / data.rdv) * 100 : 0,
      }));

    return perfHistory;
  }

  async getStatistics(
    period: PeriodType,
    entityType?: StatEntityType,
    entityId?: string,
  ) {


  }
}



# --- immeuble/immeuble.service.ts ---
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateImmeubleDto } from './dto/create-immeuble.dto';
import { UpdateImmeubleDto } from './dto/update-immeuble.dto';

@Injectable()
export class ImmeubleService {
  constructor(private prisma: PrismaService) {}

  create(createImmeubleDto: CreateImmeubleDto) {
    return this.prisma.immeuble.create({ data: createImmeubleDto });
  }

  findAll() {
    return this.prisma.immeuble.findMany({ include: { zone: true, prospectors: true } });
  }

  findOne(id: string) {
    return this.prisma.immeuble.findUnique({ where: { id }, include: { zone: true, prospectors: true, portes: true } });
  }

  async getImmeubleDetails(immeubleId: string) {
    const immeuble = await this.prisma.immeuble.findUnique({
      where: { id: immeubleId },
      include: {
        prospectors: true,
        portes: true,
        historiques: true,
        zone: true,
      },
    });

    if (!immeuble) {
      throw new NotFoundException(`Immeuble with ID ${immeubleId} not found`);
    }

    const stats = immeuble.historiques.reduce(
      (acc, h) => {
        acc.contratsSignes += h.nbContratsSignes;
        acc.rdvPris += h.nbRdvPris;
        return acc;
      },
      { contratsSignes: 0, rdvPris: 0 },
    );

    let portesAffichees = immeuble.portes;
    if (immeuble.prospectingMode === 'SOLO') {
      // Pour SOLO, on ne filtre que sur le papier, mais on les affiche toutes
      // La logique de filtrage pair/impair sera sur le front si nécessaire
    } else if (immeuble.prospectingMode === 'DUO') {
        // Aucune filtration spécifique ici, on les affiche toutes
    }

    return {
      ...immeuble,
      stats,
      portes: portesAffichees,
    };
  }

  update(id: string, updateImmeubleDto: UpdateImmeubleDto) {
    return this.prisma.immeuble.update({ where: { id }, data: updateImmeubleDto });
  }

  remove(id: string) {
    return this.prisma.immeuble.delete({ where: { id } });
  }
}



# --- send_to_gemini.py ---
import os

EXCLUDED_DIRS = {"node_modules", ".git", ".next", ".turbo", "dist", "build"}
TEXT_EXTENSIONS = {'.ts', '.tsx', '.js', '.jsx', '.json', '.html', '.css', '.md', '.txt', '.py'}

def get_all_files(root_dir):
    result = []

    for foldername, _, filenames in os.walk(root_dir):
        if any(excluded in foldername for excluded in EXCLUDED_DIRS):
            continue

        for filename in filenames:
            filepath = os.path.join(foldername, filename)
            ext = os.path.splitext(filename)[1].lower()
            if ext in TEXT_EXTENSIONS:
                result.append(filepath)

    return result

def read_file_content(filepath):
    try:
        with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except:
        return ""

def export_balanced_parts(root_dir, output_base="code_part"):
    all_files = get_all_files(root_dir)

    # Lire tous les fichiers avec leur contenu
    file_entries = []
    for path in all_files:
        content = read_file_content(path)
        relative_path = os.path.relpath(path, root_dir)
        wrapped_content = f"\n\n# --- {relative_path} ---\n{content}\n"
        file_entries.append((relative_path, wrapped_content, len(wrapped_content)))

    # Trier les fichiers par taille (descendant)
    file_entries.sort(key=lambda x: x[2], reverse=True)

    part1, part2 = [], []
    size1, size2 = 0, 0

    for _, content, size in file_entries:
        if size1 <= size2:
            part1.append(content)
            size1 += size
        else:
            part2.append(content)
            size2 += size

    with open(f"{output_base}1.txt", "w", encoding="utf-8") as f1:
        f1.writelines(part1)

    with open(f"{output_base}2.txt", "w", encoding="utf-8") as f2:
        f2.writelines(part2)

    print(f"✅ Fichiers générés : {output_base}1.txt ({size1} car.), {output_base}2.txt ({size2} car.)")

if __name__ == "__main__":
    export_balanced_parts("./")



# --- statistics/statistics.controller.ts ---
import { Controller, Get, Query, Param } from '@nestjs/common';
import { StatisticsService } from './statistics.service';
import { PeriodType, StatEntityType } from '@prisma/client';

@Controller('statistics')
export class StatisticsController {
  constructor(private readonly statisticsService: StatisticsService) {}

  @Get('commercial/:id/history')
  getCommercialHistory(@Param('id') id: string) {
    return this.statisticsService.getProspectingHistoryForCommercial(id);
  }

  @Get('commercial/:id')
  getCommercialStats(@Param('id') id: string) {
    return this.statisticsService.getStatsForCommercial(id);
  }

  @Get('manager/:id')
  getManagerStats(@Param('id') id: string) {
    return this.statisticsService.getStatsForManager(id);
  }

  @Get('manager/:id/history')
  getManagerPerformanceHistory(@Param('id') id: string) {
    return this.statisticsService.getManagerPerformanceHistory(id);
  }

  @Get()
  getStatistics(
    @Query('period') period: PeriodType,
    @Query('entityType') entityType?: StatEntityType,
    @Query('entityId') entityId?: string,
  ) {
    return this.statisticsService.getStatistics(period, entityType, entityId);
  }
}



# --- commercial/commercial.service.ts ---
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateCommercialDto } from './dto/create-commercial.dto';
import { UpdateCommercialDto } from './dto/update-commercial.dto';

@Injectable()
export class CommercialService {
  constructor(private prisma: PrismaService) {}

  create(createCommercialDto: CreateCommercialDto) {
    return this.prisma.commercial.create({ data: createCommercialDto });
  }

  findAll() {
    return this.prisma.commercial.findMany({
      include: {
        equipe: {
          include: {
            manager: true,
          },
        },
        historiques: true, // Include historiques to sum contracts
      },
    });
  }

  findOne(id: string) {
    return this.prisma.commercial.findUnique({ where: { id }, include: { equipe: { include: { manager: true } } } });
  }

  update(id: string, updateCommercialDto: UpdateCommercialDto) {
    return this.prisma.commercial.update({ where: { id }, data: updateCommercialDto });
  }

  remove(id: string) {
    return this.prisma.commercial.delete({ where: { id } });
  }
}



# --- manager/manager.service.ts ---
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateManagerDto } from './dto/create-manager.dto';
import { UpdateManagerDto } from './dto/update-manager.dto';

@Injectable()
export class ManagerService {
  constructor(private prisma: PrismaService) {}

  create(createManagerDto: CreateManagerDto) {
    return this.prisma.manager.create({ data: createManagerDto });
  }

  findAll() {
    return this.prisma.manager.findMany({
      include: {
        equipes: {
          include: {
            commerciaux: {
              include: {
                historiques: true,
              },
            },
          },
        },
      },
    });
  }

  findOne(id: string) {
    return this.prisma.manager.findUnique({ where: { id }, include: { equipes: { include: { commerciaux: true } } } });
  }

  update(id: string, updateManagerDto: UpdateManagerDto) {
    return this.prisma.manager.update({ where: { id }, data: updateManagerDto });
  }

  remove(id: string) {
    return this.prisma.manager.delete({ where: { id } });
  }
}



# --- commercial/commercial.controller.ts ---
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CommercialService } from './commercial.service';
import { CreateCommercialDto } from './dto/create-commercial.dto';
import { UpdateCommercialDto } from './dto/update-commercial.dto';

@Controller('commerciaux')
export class CommercialController {
  constructor(private readonly commercialService: CommercialService) {}

  @Post()
  create(@Body() createCommercialDto: CreateCommercialDto) {
    return this.commercialService.create(createCommercialDto);
  }

  @Get()
  findAll() {
    return this.commercialService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.commercialService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCommercialDto: UpdateCommercialDto) {
    return this.commercialService.update(id, updateCommercialDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.commercialService.remove(id);
  }
}



# --- manager/manager.controller.ts ---
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ManagerService } from './manager.service';
import { CreateManagerDto } from './dto/create-manager.dto';
import { UpdateManagerDto } from './dto/update-manager.dto';

@Controller('managers')
export class ManagerController {
  constructor(private readonly managerService: ManagerService) {}

  @Post()
  create(@Body() createManagerDto: CreateManagerDto) {
    return this.managerService.create(createManagerDto);
  }

  @Get()
  findAll() {
    return this.managerService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.managerService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateManagerDto: UpdateManagerDto) {
    return this.managerService.update(id, updateManagerDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.managerService.remove(id);
  }
}



# --- porte/porte.controller.ts ---
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { PorteService } from './porte.service';
import { CreatePorteDto } from './dto/create-porte.dto';
import { UpdatePorteDto } from './dto/update-porte.dto';

@Controller('portes')
export class PorteController {
  constructor(private readonly porteService: PorteService) {}

  @Post()
  create(@Body() createPorteDto: CreatePorteDto) {
    return this.porteService.create(createPorteDto);
  }

  @Get()
  findAll() {
    return this.porteService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.porteService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePorteDto: UpdatePorteDto) {
    return this.porteService.update(id, updatePorteDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.porteService.remove(id);
  }
}



# --- app.controller.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});



# --- prisma/prisma.service.ts ---
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }

  async enableShutdownHooks(app: INestApplication) {
    (this as any).$on('beforeExit', async () => {
      await app.close();
    });
  }
}


# --- statistics/statistics.module.ts ---
import { Module } from '@nestjs/common';
import { StatisticsService } from './statistics.service';
import { StatisticsController } from './statistics.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [StatisticsController],
  providers: [StatisticsService],
})
export class StatisticsModule {}



# --- immeuble/immeuble.module.ts ---
import { Module } from '@nestjs/common';
import { ImmeubleService } from './immeuble.service';
import { ImmeubleController } from './immeuble.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [ImmeubleController],
  providers: [ImmeubleService],
})
export class ImmeubleModule {}



# --- equipe/equipe.module.ts ---
import { Module } from '@nestjs/common';
import { EquipeService } from './equipe.service';
import { EquipeController } from './equipe.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [EquipeController],
  providers: [EquipeService],
})
export class EquipeModule {}



# --- zone/zone.module.ts ---
import { Module } from '@nestjs/common';
import { ZoneService } from './zone.service';
import { ZoneController } from './zone.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [ZoneController],
  providers: [ZoneService],
})
export class ZoneModule {}



# --- app.controller.ts ---
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}



# --- immeuble/dto/update-immeuble.dto.ts ---
import { PartialType } from '@nestjs/mapped-types';
import { CreateImmeubleDto } from './create-immeuble.dto';

export class UpdateImmeubleDto extends PartialType(CreateImmeubleDto) {}



# --- prisma/prisma.module.ts ---
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}



# --- equipe/dto/update-equipe.dto.ts ---
import { PartialType } from '@nestjs/mapped-types';
import { CreateEquipeDto } from './create-equipe.dto';

export class UpdateEquipeDto extends PartialType(CreateEquipeDto) {}



# --- zone/dto/update-zone.dto.ts ---
import { PartialType } from '@nestjs/mapped-types';
import { CreateZoneDto } from './create-zone.dto';

export class UpdateZoneDto extends PartialType(CreateZoneDto) {}



# --- app.service.ts ---
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}



# --- equipe/dto/create-equipe.dto.ts ---
export class CreateEquipeDto {
  nom: string;
  managerId: string;
}

